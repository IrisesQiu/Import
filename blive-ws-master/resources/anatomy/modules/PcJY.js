/**
 * id: PcJY
 * path: ./cas
 */

(function(require,module,exports) {
"use strict";function e(e,n,t){var a=r(e,e.VERTEX_SHADER,n),o=r(e,e.FRAGMENT_SHADER,t),c=e.createProgram();if(null==c)throw Error("Can't create shader program");if(e.attachShader(c,a),e.attachShader(c,o),e.linkProgram(c),!e.getProgramParameter(c,e.LINK_STATUS))throw Error("Unable to initialize the shader program");return c}function r(e,r,n){var t=e.createShader(r);if(null==t)throw Error("Can't create shader");if(e.shaderSource(t,n),e.compileShader(t),!e.getShaderParameter(t,e.COMPILE_STATUS)){var a=e.getShaderInfoLog(t);throw e.deleteShader(t),Error(null!=a?a:"An error occurred compiling the shaders")}return t}function n(e,r,n){e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n),e.drawArrays(e.TRIANGLES,0,6)}function t(e){var r=e.createTexture();if(null==r)throw Error("Could not create texture");e.bindTexture(e.TEXTURE_2D,r);var n=e.RGBA,t=e.RGBA,a=e.UNSIGNED_BYTE,o=new Uint8Array([0,0,255,255]);return e.texImage2D(e.TEXTURE_2D,0,n,1,1,0,t,a,o),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),r}Object.defineProperty(exports,"__esModule",{value:!0}),exports.videoCAS=void 0;var a=[-1,1,-1,-1,1,-1,1,-1,1,1,-1,1],o=[0,1,0,0,1,0,1,0,1,1,0,1];function c(r,n,t){if(null==r)throw Error("Cant create gl context");var c=e(r,g,v);r.useProgram(c),r.uniform1f(r.getUniformLocation(c,"srcWidth"),n),r.uniform1f(r.getUniformLocation(c,"srcHeight"),t),r.uniform1i(r.getUniformLocation(c,"frameTexture"),0);var i=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,i),r.bufferData(r.ARRAY_BUFFER,new Float32Array(a),r.STATIC_DRAW);var f=r.getAttribLocation(c,"aPos");r.vertexAttribPointer(f,2,r.FLOAT,!1,2*Float32Array.BYTES_PER_ELEMENT,0),r.enableVertexAttribArray(f);var l=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,l),r.bufferData(r.ARRAY_BUFFER,new Float32Array(o),r.STATIC_DRAW);var u=r.getAttribLocation(c,"aTexCoord");r.vertexAttribPointer(u,2,r.FLOAT,!1,2*Float32Array.BYTES_PER_ELEMENT,0),r.enableVertexAttribArray(u)}function i(e,r){function n(){e.width=r.videoWidth,e.height=r.videoHeight;["width","height","position","left","top","zIndex","overflow"].forEach(function(n){e.style[n]=r.style[n]});var n=r.style.objectFit;e.style.objectFit=0===n.length?"contain":n}n();var t=new MutationObserver(function(e){e.some(function(e){return"style"===e.attributeName})&&n()});return t.observe(r,{attributes:!0}),function(){t.disconnect()}}function f(e){var r=document.createElement("canvas");if("VIDEO"!==e.tagName)return{canvas:r,supported:!1,stop:function(){}};var a=i(r,e),o=!0,f=null,v=r.getContext("webgl2");null==v?l():(c(v,e.videoWidth,e.videoHeight),f=t(v),function r(){if(null==v||null==f)return;n(v,f,e);g=requestAnimationFrame(r)}());var g=0;function l(){a(),null==r||r.remove(),o=!1,cancelAnimationFrame(g)}return{canvas:r,supported:o,stop:l}}exports.videoCAS=f;var v="#version 300 es\n// Copyright (c) 2023 Bilibili Inc. All rights reserved.\n// ======================================================================\n// Bili Mobile Super Resolution [BMSR] - scaling & sharpening & vibrance\n// v0.2.7\n// ======================================================================\nprecision highp float;\nout vec4 FragColor;\n\nin vec2 TexCoord;\n\nuniform sampler2D frameTexture;\nuniform float srcWidth; //input width\nuniform float srcHeight; //input height\nconst float usmCoeff = 1.2; // for usm v2, range [1.0, 1.5]\nconst float upperCoeff = 0.5; // range [0.0, 1.0]\nconst float lowerCoeff = 0.5; // range [0.0, 1.0]\nconst float vibCoeff = 0.2; // range [0.0, 0.5)\nconst float brightCoeff = 0.15; // range [0.0, 0.3]\n\nconst float lobe = 0.25; // default 0.25\nconst float eps = 1.0e-8;\n\nvoid calcMeanVar(\n    inout vec3 aMean,\n    inout vec3 aVar,\n    float w,\n    vec3 a, vec3 b, vec3 c, vec3 d, vec3 e\n) {\n    vec3 sum = a + b + c + d + e;\n    vec3 mean = sum / 5.0;\n    vec3 sum2 = a * a + b * b + c * c + d * d + e * e;\n    vec3 var = sum2 / 5.0 - mean * mean;\n    aMean += w * mean;\n    aVar += w * var;\n}\n\nvoid vibranceV2(\n    inout vec3 rgbUSM,\n    vec3 rgbRS\n) {\n    float rgbMax = max(rgbRS.r, max(rgbRS.g, rgbRS.b));\n    float rgbMin = min(rgbRS.r, min(rgbRS.g, rgbRS.b));\n    float delta = rgbMax - rgbMin;\n    float flag = step(eps, delta);\n    float value = rgbMax + rgbMin;\n    float L = value / 2.0;\n    float S = delta / abs(2.0 * step(0.5, L) - value);\n    float alpha = 1.0 / clamp(1.0 - vibCoeff, S, 1.0) - 1.0;\n    rgbUSM = rgbUSM + flag * alpha * (rgbUSM - L);\n}\n\nvoid lanczos2(\n    inout vec3 aC,\n    inout float aW,\n    vec2 off,\n    vec3 c\n) {\n    vec2 wA = 0.4 * off * off - 1.0;\n    wA = 1.5625 * wA * wA - 0.5625;\n    vec2 wB = lobe * off * off - 1.0;\n    wB *= wB;\n    wB *= wA;\n    float w = wB.x * wB.y;\n    aC += w * c;\n    aW += w;\n}\n\nvoid main() {\n    vec2 invSrc = vec2(1.0 / srcWidth, 1.0 / srcHeight);\n    vec2 pp = TexCoord * vec2(srcWidth, srcHeight) - 0.5; // output texture coordinate in the input pixel coordinate\n    vec2 fp = floor(pp); // fp is F in the pixel coordinate\n    pp -= fp; // offset to the top left f\n    fp = fp + 0.5; // make fp being the pixel coordinate corresponding to f in the texture coordinate\n    vec3 bC = texture(frameTexture, (fp + vec2(0.0, -1.0)) * invSrc).rgb;\n    vec3 cC = texture(frameTexture, (fp + vec2(1.0, -1.0)) * invSrc).rgb;\n    vec3 eC = texture(frameTexture, (fp + vec2(-1.0, 0.0)) * invSrc).rgb;\n    vec3 fC = texture(frameTexture, fp * invSrc).rgb;\n    vec3 gC = texture(frameTexture, (fp + vec2(1.0, 0.0)) * invSrc).rgb;\n    vec3 hC = texture(frameTexture, (fp + vec2(2.0, 0.0)) * invSrc).rgb;\n    vec3 iC = texture(frameTexture, (fp + vec2(-1.0, 1.0)) * invSrc).rgb;\n    vec3 jC = texture(frameTexture, (fp + vec2(0.0, 1.0)) * invSrc).rgb;\n    vec3 kC = texture(frameTexture, (fp + vec2(1.0, 1.0)) * invSrc).rgb;\n    vec3 lC = texture(frameTexture, (fp + vec2(2.0, 1.0)) * invSrc).rgb;\n    vec3 nC = texture(frameTexture, (fp + vec2(0.0, 2.0)) * invSrc).rgb;\n    vec3 oC = texture(frameTexture, (fp + vec2(1.0, 2.0)) * invSrc).rgb;\n    vec3 rgbRS = vec3(0.0);\n    float aW = 0.0;\n    lanczos2(rgbRS, aW, vec2(0.0, -1.0) - pp, bC);\n    lanczos2(rgbRS, aW, vec2(1.0, -1.0) - pp, cC);\n    lanczos2(rgbRS, aW, vec2(-1.0, 0.0) - pp, eC);\n    lanczos2(rgbRS, aW, vec2(0.0, 0.0) - pp, fC);\n    lanczos2(rgbRS, aW, vec2(1.0, 0.0) - pp, gC);\n    lanczos2(rgbRS, aW, vec2(2.0, 0.0) - pp, hC);\n    lanczos2(rgbRS, aW, vec2(-1.0, 1.0) - pp, iC);\n    lanczos2(rgbRS, aW, vec2(0.0, 1.0) - pp, jC);\n    lanczos2(rgbRS, aW, vec2(1.0, 1.0) - pp, kC);\n    lanczos2(rgbRS, aW, vec2(2.0, 1.0) - pp, lC);\n    lanczos2(rgbRS, aW, vec2(0.0, 2.0) - pp, nC);\n    lanczos2(rgbRS, aW, vec2(1.0, 2.0) - pp, oC);\n    rgbRS /= aW;\n    rgbRS = clamp(rgbRS, 0.0, 1.0);\n    vec3 mean = vec3(0.0);\n    vec3 var = vec3(0.0);\n    calcMeanVar(mean, var, (1.0 - pp.x) * (1.0 - pp.y), bC, eC, fC, gC, jC);\n    calcMeanVar(mean, var, pp.x * (1.0 - pp.y), cC, fC, gC, hC, kC);\n    calcMeanVar(mean, var, (1.0 - pp.x) * pp.y, fC, iC, jC, kC, nC);\n    calcMeanVar(mean, var, pp.x * pp.y, gC, jC, kC, lC, oC);\n    vec3 W = usmCoeff + 1.0 / (var + 1.0);\n    vec3 rgbUSM = mean + W * (rgbRS - mean);\n    vec3 diff = rgbUSM - rgbRS;\n    vec3 rgbRS2 = rgbRS * rgbRS;\n    vec3 maxDiff = 0.5 * rgbRS2 * rgbRS2 - 1.32 * rgbRS2 * rgbRS + 1.12 * rgbRS2 - 0.38 * rgbRS + 0.08;\n    vec3 minDiff = maxDiff - 0.08;\n    rgbUSM = rgbRS + min(max(diff, minDiff), maxDiff);\n    rgbUSM = clamp(rgbUSM, 0.0, 1.0);\n    vibranceV2(rgbUSM, rgbRS);\n    rgbUSM = -brightCoeff * rgbUSM * rgbUSM + (1.0 + brightCoeff) * rgbUSM;\n    FragColor = vec4(rgbUSM, 1.0);\n}",g="#version 300 es\nlayout (location = 0) in vec2 aPos;\nlayout (location = 1) in vec2 aTexCoord;\n\nout vec2 TexCoord;\n\nvoid main()\n{\n    gl_Position = vec4(aPos, 0.0, 1.0);\n    TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);\n}";
})()